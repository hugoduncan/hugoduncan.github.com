<!DOCTYPE html>
<html lang="en">
  <head>
    <title>lisp</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta charset="utf-8"/>
    <meta name="description"
          content="Pelure - ephemeral writing surface?"/>
    <meta name="author" content="Hugo Duncan"/>
    <link type="application/atom+xml" rel="alternate" href="../../index.xml" title="Pelure">
    <link rel="stylesheet" href="../../style.css">
  </head>
  <body>

    <div class="site-header">
      <div class="wrapper">
        <div class="site-nav">
          <a class="page-link" href="../../archive.html">All Posts</a>
          <a class="page-link" href="https://github.com/hugoduncan/hugoduncan.github.com/discussions/categories/posts">Discuss</a>
          <a class="page-link" href="../../meta/pelure.html">About</a>
          <a class="page-link" href="../../meta/contact.html">Contact</a>
          <a class="page-link" href="index.xml">
            <img class="page-icon"
                 src="https://www.svgrepo.com/show/362316/feed.svg"
                 width="30px"/>
          </a>
          <a class="page-link" href="https://twitter.com/hugoduncan">
            <img class="page-icon"
                 src="https://www.svgrepo.com/show/11841/twitter.svg"
                 width="30px"/>
          </a>
        </div>
        <div>
          <h1 class="site-title">
            <a class="page-link" href="../../index.html">Pelure</a>
          </h1>
          <p>Ephemeral musings, often about Clojure</p>
        </div>
      </div>
    </div>

    <div class="wrapper">

      <div><h1><a href="post/mocking_clojure_functions_with_atticus.html">Mocking Clojure Functions with Atticus</a></h1><p><p>I dislike most mocking, and try and avoid it as much as possible. Sometimes it is however the only realistic way of testing.  I did a quick survey of mocking tools in clojure, and found them very much reflecting the Java mocking libraries. Clojure has a few more dynamic capabilities than Java, so I thought a little about how these could be used to make a simple mocking facility, and <a href="http://github.com/hugoduncan/atticus">atticus</a> is what I came up with.</p> <p>There is a consensus that mocking should be implemented by binding a function's var to a new function for the duration of a test, and atticus does this too. Atticus' premise is that we can do simple mocking by declaring the mock function as a local function definition, and have the local function do the argument checking, return value setting, etc.  The simplest case would be something like below, which checks the value of its argument and specifies a return value:</p> <pre class="clojure"> ;; pull in namespaces (use 'clojure.test) (require 'atticus.mock)</p><p>;; define test which mocks f (deftest mock-test   (atticus.mock/expects     [(f [arg]        (is (= arg 1) "Check argument")        arg)] ; set the return value     ;; in a real test case this would be called     ;; indirectly by some other function     (is (= 1 (f 1)) "Call mocked function")) </pre> <p>At the moment, I have added two macros to this.  <code>once</code>, which checks a function is called once, and <code>times</code>, which checks that a function is called a specific number of times. The macros are used to wrap the body of the mock function, which keeps the function's expected behaviour in one place.</p> <pre class="clojure"> ;; define test, that should be called just once (deftest mock-test   (atticus.mock/expects     [(f [arg]        (atticus.mock/once          (is (= arg 1) "Check argument")          arg))]     (is (= 1 (f 1)) "Call mocked function")) </pre> <pre class="clojure"> ;; define test, that should be called exactly twice (deftest mock-test   (atticus.mock/expects     [(f [arg]        (atticus.mock/times 2          (is (= arg 1) "Check argument")          arg))]     (is (= 1 (f 1)) "Call mocked function")     (is (= 1 (f 1)) "Call mocked function")) </pre> <p>So what do you think, is this a reasonable approach? Not having the explicit calls to <code>returns</code>, etc, might be seen as a loss of declarative clarity, but I for one prefer this, as it gives you the full power of the language to test the arguments and set the return value.</p> <h3>References</h3> <ul> <li><a href="http://s-expressions.com/2010/01/24/conjure-simple-mocking-and-stubbing-for-clojure-unit-tests/">conjure – simple mocking and stubbing for Clojure unit-tests</a></li> <li><a href="http://richhickey.github.com/clojure-contrib/mock-api.html">clojure.contrib.mock</a></li> <li><a href="http://code.google.com/p/test-expect/">test-expect</a></li> <li><a href="http://blog.n01se.net/?p=134">Using binding to mock out even “direct linked” functions in Clojure</a></li> </ul></p><p>Discuss this post <a href="https://github.com/hugoduncan/hugoduncan.github.com/discussions/categories/posts">here</a>.</p><p><i>Published: 2010-05-18</i></p></div><div><h1><a href="post/shell_scripting_in_clojure_with_pallet.html">Shell Scripting in Clojure with Pallet</a></h1><p><p>Let's face it, many of us hate writing shell scripts, and with good reason. Personally, it's not so much the shell language itself that puts me off, but organising everything around it; how do you deploy your scripts, how do you arrange to call other scripts, how do you manage the dependencies between your scripts?  <a href="http://github.com/hugoduncan/pallet">Pallet</a> aims to solve these problems by embedding shell script in <a href="http://clojure.org/">clojure</a>.</p></p><p><h2>Embedding in Clojure</h2></p><p><p>Embedding other languages in lisp is not a new idea; <a href="http://common-lisp.net/project/parenscript/">parenscript</a>, <a href="http://github.com/arohner/scriptjure">scriptjure</a> (which Pallet's embedding is based on), and <a href="http://www.gitorious.org/clojureql/">ClojureQL</a> all do this.</p></p><p><p>So what does shell script in clojure look like? Some examples:</p> <pre class="clojure">(script   (ls "/some/path")   (defvar x 1)   (println @x)   (defn foo [x] (ls @x))   (foo 1)   (if (= a a)     (println "Reassuring")     (println "Ooops"))   (println "I am" @(whomai))</pre></p><p><p>which generates:</p></p><p><pre>ls /some/path x=1 echo ${x} function foo(x) { ls ${x}  } foo 1 if [ &#92;( \"a\" == \"a\" &#92;) ]; then echo Reassuring;else echo Ooops;fi echo I am $(whomai) </pre></p><p><p>The aim is to make writing shell script similar to writing Clojure, but there are obvious differences in the language that limit how far that can be taken. To run the code above at the REPL, you'll have to use the <code>pallet.stevedore</code> package.</p></p><p><h2>Escaping back to Clojure</h2></p><p><p>Escaping allows us to embed Clojure values and expressions inside our scripts, in much the same way as symbols can be unquoted when writing macros.</p></p><p><pre class="clojure">(let [path "/some/path"]   (script     (ls ~path)     (ls ~(.replace path "some" "other)))</pre></p><p><p>We can now write Clojure functions that produce shell scripts.  Writing scripts as clojure functions allows you to use the Clojure namespace facilities, and allows you to distribute you scripts in jar files (which can be deployed in a versioned manner with maven)</p></p><p><pre class="clojure">(defn list-path [path]   (script     (ls ~path)     (ls ~(.replace path "some" "other)))</pre></p><p><h2>Composing scripts</h2></p><p><p>Pallet allows the scripts to be combined. <code>do-script</code> concatenates the code pieces together.</p></p><p><pre class="clojure">(do-script   (list-path "path1")   (list-path "path2")) </pre></p><p><p><code>chain-script</code> chains the scripts together with '&amp;&amp;'.</p></p><p><pre class="clojure">(chain-script   (list-path "path1")   (list-path "path2")) </pre></p><p><p><code>checked-script</code> finally allows the chaining of scripts, and calls exit if the chain fails.</p></p><p><pre class="clojure">(checked-script "Message"   (list-path "path1")   (list-path "path2")) </pre></p><p><h2>Conclusion</h2></p><p><p>Writing shell script in Clojure gives access to Clojure's namespace facility allowing modularised shell script, and to Clojure's packaging as jar files, which allows reuse and distribution.  The ability to compose script fragments leads to being able to macro-like functions, such <code>checked-script</code>, and you could even use Clojure macros to generate script (but I haven't thought of a use for that, yet).</p></p><p><p>The syntax for the embedding has arisen out of practical usage, so is far from complete, and can definitely be improved. I look forward to hearing your feedback!</p></p><p><p>UPDATE: stevedore now requires a binding for <em>template</em>, to specify the target for the script generation.  This should be a vector containing one of :ubuntu, :centos, or :darwin, and one of :aptitude, :yum, :brew.</p></p><p>Discuss this post <a href="https://github.com/hugoduncan/hugoduncan.github.com/discussions/categories/posts">here</a>.</p><p><i>Published: 2010-05-03</i></p></div><div><h1><a href="post/swank_clojure_gets_a_break_with_the_local_environment.html">Swank Clojure gets a Break with the Local Environment</a></h1><p>Recently I got fed up with a couple of warts in swank-clojure, so I made a couple of small fixes, and that lead to a couple of new features.  Using SLIME with Clojure has never been as smooth as using it with Common Lisp, and the lack of debug functionality beyond the display of stack traces is particularly onerous.  Recently, George Jahad and Alex Osborne's <a href="http://github.com/GeorgeJahad/debug-repl">debug-repl</a> showed the possibility of adding a break macro to enter the debugger with the call stack intact and local variables visible.  This functionality is now in swank-clojure.</p><p>Consider the following example, adapted from debug-repl:</p><p><pre>   (let [c 1
        d 2]     (defn a [b c]       (swank.core/break)       d))   (a "foo" "bar") </pre></p><p>Running this now brings up the following SLDB debug frame:</p><p><pre> BREAK:   [Thrown class java.lang.Exception]</p><p>Restarts:  0: [QUIT] Quit to the SLIME top level  1: [CONTINUE] Continue from breakpoint</p><p>Backtrace:   0: user$eval<b>1666$a</b>1667.invoke(NO<i>SOURCE</i>FILE:1)   1: user$eval__1670.invoke(NO<i>SOURCE</i>FILE:1)   2: clojure.lang.Compiler.eval(Compiler.java:5358)   3: clojure.lang.Compiler.eval(Compiler.java:5326)   4: clojure.core$eval__4157.invoke(core.clj:2139)   &ndash;more&ndash; </pre></p><p><p>As you can see, the stack trace reflects the location of the breakpoint, and there is a CONTINUE restart. Pressing "1", or Enter on the CONTINUE line, or clicking the CONTINUE line should all cause the the debugger frame to close, and the result of the function call, 2, to be displayed in the REPL frame.</p></p><p><p>Enter, or "t", on the first line of the stacktrace causes the local variables to be displayed:</p> <pre> BREAK:   [Thrown class java.lang.Exception]</p><p>Restarts:  0: [QUIT] Quit to the SLIME top level  1: [CONTINUE] Continue from breakpoint</p><p>Backtrace:   0: user$eval<b>1666$a</b>1667.invoke(NO<i>SOURCE</i>FILE:1)       Locals:         b = foo         d = 2         c = bar   1: user$eval__1670.invoke(NO<i>SOURCE</i>FILE:1)   2: clojure.lang.Compiler.eval(Compiler.java:5358)   3: clojure.lang.Compiler.eval(Compiler.java:5326)   4: clojure.core$eval__4157.invoke(core.clj:2139)   &ndash;more&ndash; </pre></p><p><p>Pressing enter on one of the local variable lines will pull up the SLIME inspector with that value. If you go back to the REPL without closing the SLDB frame, there will be no prompt, but pressing enter should give you one.  The local variables are then all be avaiable for evaluation form the REPL.</p></p><p><p>Should an error occur while you are using the REPL, you will be placed in a nested debug session, with an "ABORT" restart to return to the previous debug level.</p></p><p><p>Finally, restarts are now displayed for each of the exceptions in the exception cause chain.</p></p><p><pre>   (let [c 1
        d 2]     (defn a [b c]       (throw (Exception. "top" (Exception. "nested" (Exception. "bottom"))))       d))   (a "foo" "bar") </pre></p><p><p>This will bring up the debugger with 2 cause restarts, which can be used to examine the related stack traces.</p></p><p><pre> top    [Thrown class java.lang.Exception]</p><p>Restarts:   0: [QUIT] Quit to the SLIME top level   1: [CAUSE1] Invoke debugger on cause  nested [Thrown class java.lang.Exception]   2: [CAUSE2] Invoke debugger on cause   bottom [Thrown class java.lang.Exception]</p><p>Backtrace:    0: user$eval<b>1752$a</b>1753.invoke(NO<i>SOURCE</i>FILE:1)    1: user$eval__1756.invoke(NO<i>SOURCE</i>FILE:1)    2: clojure.lang.Compiler.eval(Compiler.java:5358)    3: clojure.lang.Compiler.eval(Compiler.java:5326)    4: clojure.core$eval__4157.invoke(core.clj:2139)   &ndash;more&ndash; </pre></p><p><p>The break functionality is known only to work from the REPL thread at the moment.  With that small proviso, I hope you enjoy the new functionality - at least it provides a basic debug functionality until full JPDA/JDI integration is tackled.</p></p><p>Discuss this post <a href="https://github.com/hugoduncan/hugoduncan.github.com/discussions/categories/posts">here</a>.</p><p><i>Published: 2010-03-31</i></p></div>

      
      <div style="margin-bottom: 20px; float: right;">
        <a class="page-link" href="archive.html">Archive</a>
      </div>
      
    </div>
    <script>
      document.addEventListener('DOMContentLoaded', (event) => {
        document.querySelectorAll('pre code').forEach((el) => {
          if (!el.classList.contains('clojure')) {
            hljs.highlightElement(el);
          }
        });
      });
    </script>
  </body>
</html>
