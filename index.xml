<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en-us'>
 <title>pelure</title>
 <id>http://hugoduncan.github.com/</id>
 <link href='./' />
 <link rel='self' href='' />
 <logo>rsslogo.jpg</logo>
 <icon>/favicon.ico</icon>
 <author><name>Hugo Duncan</name></author>
 <subtitle>Pelure </subtitle>
 <rights>All content written by Hugo Duncan and photos by Hugo Duncan Copyright Hugo Duncan, all rights reserved.</rights> 
 <updated>2013-10-28T00:00:00Z</updated>


<entry xml:base="http://hugoduncan.github.com/post/generating_source_with_leiningen"><title>Generating Source Files with Leiningen</title><link href="http://hugoduncan.github.com/post/generating_source_with_leiningen"/><id>http://hugoduncan.github.com/post/generating_source_with_leiningen</id><published>2013-10-28T00:00:00Z</published><updated>2013-10-28T00:00:00Z</updated><summary type="html"> </summary><content type="html">&lt;p&gt;Recently, we needed to include some generated source files in a
project.  The source code generation was project specific, so we
didn&amp;rsquo;t want to have to create a leiningen plugin specifically for it.
To get this to work required using quite a few of
&lt;a href=&#34;https://github.com/technomancy/leiningen#leiningen&#34;&gt;leiningen&amp;rsquo;s&lt;/a&gt;
features.&lt;/p&gt;

&lt;p&gt;This post will explain how to use lein to customise you build to
generates a source file, but many of the steps are useful to
implement any form of lein build customisation.&lt;/p&gt;

&lt;h3&gt;The Generator&lt;/h3&gt;

&lt;p&gt;The source code generator is going to live in the &lt;code&gt;my.src-generator&lt;/code&gt;
namespace.  Here&amp;rsquo;s an example, that just generates a namespace
declaration for the &lt;code&gt;my.gen&lt;/code&gt; namespace under
&lt;code&gt;target/generated/my/gen.clj&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;(ns my.src-generator
  (:require [clojure.java.io :refer [file]]))

(defn generate []
  (doto (file &amp;quot;target&amp;quot; &amp;quot;generated&amp;quot; &amp;quot;my&amp;quot; &amp;quot;gen.clj&amp;quot;)
    (-&amp;gt; #(.getParentFile) #(.mkdirs))
    (spit &amp;quot;(ns my.gen)&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Development only code&lt;/h3&gt;

&lt;p&gt;The source generation code should not be packaged in the jar, so we
place it in &lt;code&gt;dev-src/my/src_generator.clj&lt;/code&gt;, and add &lt;code&gt;dev-src&lt;/code&gt; and the
generated source directories to the &lt;code&gt;:dev&lt;/code&gt; profile&amp;rsquo;s &lt;code&gt;:source-paths&lt;/code&gt;.
The &lt;code&gt;:dev&lt;/code&gt; profile is automatically used by leiningen unless it is
producing a jar file.  When producing the jar, the &lt;code&gt;dev&lt;/code&gt; profile will
not be used, so &lt;code&gt;dev-src&lt;/code&gt; will not be on the &lt;code&gt;:source-path&lt;/code&gt; (we add
the generated directory to the base &lt;code&gt;:source-path&lt;/code&gt; below).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;:profiles {:dev {:source-paths [&amp;quot;src&amp;quot; &amp;quot;dev-src&amp;quot; &amp;quot;target/generated&amp;quot;]}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Running project specific code with leininingen&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;run&lt;/code&gt; task can be used to invoke code in your project.  To use
lein&amp;rsquo;s &lt;code&gt;run&lt;/code&gt; task we need to add a &lt;code&gt;-main&lt;/code&gt; function to the
&lt;code&gt;my.src-generator&lt;/code&gt; namespace.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;(defn -main [&amp;amp; args]
  (generate))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;project.clj&lt;/code&gt; file we also tell lein about the main namespace.
In order to avoid AOT compilation of the main namespace, we mark it
with &lt;code&gt;:skip-aot&lt;/code&gt; metadata.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;:main ^:skip-aot my.src-generator
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Customising the jar contents&lt;/h3&gt;

&lt;p&gt;The generated files need to end up in the jar (and possibly be
compiled), so we put them on the &lt;code&gt;:source-paths&lt;/code&gt; in the project.  If
we had wanted to include the sources without further processing, we
could have added the generated directory to &lt;code&gt;:resource-paths&lt;/code&gt; instead.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;:source-paths [&amp;quot;src&amp;quot; &amp;quot;target/generated&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Extending the build process&lt;/h3&gt;

&lt;p&gt;Now we can tell lein to generate the source files whenever we use the
project.  We do this by adding the &lt;code&gt;run&lt;/code&gt; task to the &lt;code&gt;:prep-tasks&lt;/code&gt;
key.  Leiningen runs all the tasks in &lt;code&gt;:prep-tasks&lt;/code&gt; before any task
invoked by the lein command line.&lt;/p&gt;

&lt;p&gt;The tricky bit here is that the &lt;code&gt;run&lt;/code&gt; task will itself invoke the
&lt;code&gt;:prep-tasks&lt;/code&gt;, so we want to make sure we don&amp;rsquo;t end up calling the
task recursively and generating a stack overflow.  To solve this, add
a &lt;code&gt;gen&lt;/code&gt; profile, and disable the prep tasks in it.  We use the
&lt;code&gt;:replace&lt;/code&gt; metadata to ensure this definition takes precedence.  See
the
&lt;a href=&#34;https://github.com/technomancy/leiningen/blob/master/doc/PROFILES.md#merging&#34;&gt;leiningen profile documentation&lt;/a&gt;
for more information on &lt;code&gt;:replace&lt;/code&gt; and it&amp;rsquo;s sibling &lt;code&gt;:displace&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;:gen {:prep-tasks ^:replace []}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then use this profile when setting the &lt;code&gt;:prep-tasks&lt;/code&gt; key in the project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;:prep-tasks [[&amp;quot;with-profile&amp;quot; &amp;quot;+gen,+dev&amp;quot; &amp;quot;run&amp;quot;]  &amp;quot;compile&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when we run any command, the sources are generated.&lt;/p&gt;

&lt;h3&gt;Adding an alias&lt;/h3&gt;

&lt;p&gt;Finally we may want to just invoke the source generation, so let&amp;rsquo;s
create an alias to make &lt;code&gt;lein gen&lt;/code&gt; run the generator.  We need the
&lt;code&gt;gen&lt;/code&gt; profile for this, or otherwise the generator will run twice.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;:aliases {&amp;quot;gen&amp;quot; [&amp;quot;with-profile&amp;quot; &amp;quot;+gen,+dev&amp;quot; &amp;quot;run&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;The final project.clj&lt;/h3&gt;

&lt;p&gt;For reference, the final project.clj looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;(defproject my-proj &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :dependencies [[org.clojure/clojure &amp;quot;1.4.0&amp;quot;]]
  :source-paths [&amp;quot;src&amp;quot; &amp;quot;target/generated&amp;quot;]
  :main ^:skip-aot my.src-generator
  :prep-tasks [[&amp;quot;with-profile&amp;quot; &amp;quot;+gen,+dev&amp;quot; &amp;quot;run&amp;quot;]  &amp;quot;compile&amp;quot;]
  :profiles {:dev {:source-paths [&amp;quot;src&amp;quot; &amp;quot;dev-src&amp;quot; &amp;quot;target/generated&amp;quot;]}
             :gen {:prep-tasks ^:replace []}}
  :aliases {&amp;quot;gen&amp;quot; [&amp;quot;with-profile&amp;quot; &amp;quot;+gen,+dev&amp;quot; &amp;quot;run&amp;quot;]})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This required using many of lein&amp;rsquo;s features to get working - hopefully
you&amp;rsquo;ll find a use for some of them.&lt;/p&gt;
</content></entry>

<entry xml:base="http://hugoduncan.github.com/post/alembic_reloads_your_project_clj_dependencies"><title>Alembic Reloads your Leiningen project.clj Dependencies</title><link href="http://hugoduncan.github.com/post/alembic_reloads_your_project_clj_dependencies"/><id>http://hugoduncan.github.com/post/alembic_reloads_your_project_clj_dependencies</id><published>2013-08-29T00:00:00Z</published><updated>2013-08-29T00:00:00Z</updated><summary type="html"> </summary><content type="html">&lt;p&gt;You&amp;rsquo;re working away in a Clojure REPL, when you realise you need to
add a dependency.  You add the dependency to your &lt;a href=&#34;http://leiningen.org&#34; title=&#34;Leiningen&#34;&gt;leiningen&lt;/a&gt;
&lt;code&gt;project.clj&lt;/code&gt; file and then?  Instead of shutting down your REPL,
loosing whatever state you have built up, you can use
&lt;a href=&#34;https://github.com/pallet/alembic#alembic&#34; title=&#34;Alembic&#34;&gt;Alembic&lt;/a&gt; to load the new dependencies.  Simply call
&lt;code&gt;(alembic.still/load-project)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Of course, it still has to work within the confines of the JVM&amp;rsquo;s
classloaders, so you can only add dependencies, and not modify
versions or remove dependencies, but this should still cover a lot of
use cases.&lt;/p&gt;

&lt;p&gt;To use alembic on a single project, simply add it as a dependency in
your &lt;code&gt;:dev&lt;/code&gt; profile in &lt;code&gt;project.clj&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;:profiles {:dev {:dependencies [[alembic &amp;quot;0.2.0&amp;quot;]]}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make alembic available in all your projects, and it to the &lt;code&gt;:user&lt;/code&gt;
profile in &lt;code&gt;~/.lein/profiles.clj&lt;/code&gt; instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;{:user {:dependencies [[alembic &amp;quot;0.2.0&amp;quot;]]}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alembic also allows you to directly add dependencies without editing
your &lt;code&gt;project.clj&lt;/code&gt; file, using the &lt;code&gt;distill&lt;/code&gt; function.  Use this if you
are just exploring libraries, for example.&lt;/p&gt;

&lt;p&gt;Finally a big thank you to &lt;a href=&#34;http://blog.raynes.me/&#34; title=&#34;Raynes&#34;&gt;Anthony Grimes&lt;/a&gt; and the other
&lt;a href=&#34;https://github.com/flatland/&#34; title=&#34;flatland&#34;&gt;flatland&lt;/a&gt; developers for removing classlojure&amp;rsquo;s dependency
on &lt;code&gt;useful&lt;/code&gt;, which should make this all much more robust.&lt;/p&gt;
</content></entry>

<entry xml:base="http://hugoduncan.github.com/post/evaluate_clojure_in_emacs_markdown_buffers"><title>Evaluate and Format Clojure in Emacs Markdown Buffers</title><link href="http://hugoduncan.github.com/post/evaluate_clojure_in_emacs_markdown_buffers"/><id>http://hugoduncan.github.com/post/evaluate_clojure_in_emacs_markdown_buffers</id><published>2013-08-26T00:00:00Z</published><updated>2013-08-26T00:00:00Z</updated><summary type="html"> </summary><content type="html">&lt;p&gt;When writing documentation or blog posts about Clojure code, it is
very useful to be able to format Clojure code blocks using
&lt;a href=&#34;https://github.com/clojure-emacs/clojure-mode&#34; title=&#34;clojure-mode&#34;&gt;&lt;code&gt;clojure-mode&lt;/code&gt;&lt;/a&gt; and evaluate code with &lt;a href=&#34;https://github.com/clojure-emacs/nrepl.el&#34; title=&#34;nrepl.el&#34;&gt;&lt;code&gt;nrepl.el&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This can be enabled using &lt;a href=&#34;https://github.com/purcell/mmm-mode/&#34; title=&#34;mmm-mode&#34;&gt;&lt;code&gt;mmm-mode&lt;/code&gt;&lt;/a&gt;, which
allows a single buffer to use different major modes for different
sections of the buffer (and is not limited to just web modes).
Install &lt;code&gt;mmm-mode&lt;/code&gt; using &lt;code&gt;M-x package-install mmm-mode&lt;/code&gt;,
or using &lt;code&gt;M-x el-get-install mmm-mode&lt;/code&gt; from the excellent
&lt;a href=&#34;http://tapoueh.org/emacs/el-get.html&#34; title=&#34;el-get&#34;&gt;&lt;code&gt;el-get&lt;/code&gt;&lt;/a&gt;, or by checking the project from github and
installing manually.&lt;/p&gt;

&lt;p&gt;To configure this for clojure and markdown, add this in your &lt;code&gt;init.el&lt;/code&gt;
or &lt;code&gt;.emacs&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;lisp&#34;&gt;(require &#39;mmm-auto)
(mmm-add-classes
 &#39;((markdown-clojure
    :submode clojure-mode
    :face mmm-declaration-submode-face
    :front &amp;quot;^```clj[\n\r]+&amp;quot;
    :back &amp;quot;^```$&amp;quot;)))

(setq mmm-global-mode &#39;maybe)
(mmm-add-mode-ext-class &#39;markdown-mode nil &#39;markdown-clojure)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After evaluating the above, or restarting emacs, you can test
multi-mode support by opening a markdown document, or creating a new
one, and adding a clojure source block, e.g.:&lt;/p&gt;

&lt;pre&gt;
```clj
(defn my-fn [x]
  (inc x))

(my-fn 1)
```
&lt;/pre&gt;

&lt;p&gt;Inside the code block you can format and evaluate your code as in any
&lt;code&gt;clojure-mode&lt;/code&gt; buffer, and the code will display exactly as in a
&lt;code&gt;.clj&lt;/code&gt; file.  By default the evaluation uses a running inferior lisp
process, which you must start yourself.  To use a running
&lt;a href=&#34;https://github.com/clojure-emacs/nrepl.el&#34; title=&#34;nrepl.el&#34;&gt;nrepl&lt;/a&gt; session instead, use &lt;code&gt;M-x nrepl-interaction-mode&lt;/code&gt;
inside the code block.&lt;/p&gt;

&lt;h2&gt;Using with AsciiDoc&lt;/h2&gt;

&lt;p&gt;This technique is not limited to clojure and markdown, but could be
made to work whenever you would like differing major modes in distinct
parts of your Emacs buffers.  You can add class to &lt;code&gt;mmm-mode&lt;/code&gt;
appropriately, for as many major mode combinations as you need.  The
regions for each major mode are detected using regular expressions (or
by some function).&lt;/p&gt;

&lt;p&gt;For example, if you&amp;rsquo;re writing asciidoc, you might use:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;lisp&#34;&gt;(mmm-add-classes
 &#39;((asciidoc-clojure
    :submode clojure
    :face mmm-declaration-submode-face
    :front &amp;quot;\\[source, clojure\\][\n\r]+----[\n\r]+&amp;quot;
    :back &amp;quot;^----$&amp;quot;)))
(mmm-add-mode-ext-class &#39;adoc-mode nil &#39;asciidoc-clojure)
(mmm-add-mode-ext-class &#39;doc-mode nil &#39;asciidoc-clojure)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;mmm-mode&lt;/code&gt; allows you to flexibly use multiple major modes in
different parts of a single emacs buffer.  Here we have shown how to
use it for &lt;code&gt;clojure-mode&lt;/code&gt; code blocks in markdown or asciidoc, but it
is in no way limited to this, and it allows some fine grained
customisation to the appearance and behaviour of each major mode
block. I&amp;rsquo;m sure you&amp;rsquo;ll find your own uses for &lt;code&gt;mmm-mode&lt;/code&gt;.&lt;/p&gt;
</content></entry>

<entry xml:base="http://hugoduncan.github.com/post/snarf-pgp-keys-in-emacs-mu4e"><title>Snarf PGP Keys from Signed Messages in Emacs mu4e</title><link href="http://hugoduncan.github.com/post/snarf-pgp-keys-in-emacs-mu4e"/><id>http://hugoduncan.github.com/post/snarf-pgp-keys-in-emacs-mu4e</id><published>2013-08-25T00:00:00Z</published><updated>2013-08-25T00:00:00Z</updated><summary type="html"> </summary><content type="html">&lt;p&gt;I just moved to &lt;a href=&#34;http://www.djcbsoftware.nl/code/mu/&#34; title=&#34;mu mail reader&#34;&gt;mu&lt;/a&gt; for reading my email.  One feature I was
missing was the ability to receive &lt;a href=&#34;http://en.wikipedia.org/wiki/Pretty_Good_Privacy&#34; title=&#34;Pretty Good Privacy&#34;&gt;PGP&lt;/a&gt; keys for signed
messages.&lt;/p&gt;

&lt;p&gt;When you receive a signed message, &lt;code&gt;mu&lt;/code&gt; shows the verification status
in the &lt;code&gt;Signature&lt;/code&gt; field in the message view (see
&lt;a href=&#34;http://www.djcbsoftware.nl/code/mu/mu4e/MSGV-Crypto.html#MSGV-Crypto&#34; title=&#34;mu message cryptography&#34;&gt;MSGV-Crypto&lt;/a&gt;).  If you don&amp;rsquo;t have the sender&amp;rsquo;s PGP key on
your keyring, this will show &lt;code&gt;unverified&lt;/code&gt;.  Click on the &lt;code&gt;Details&lt;/code&gt;
link within field will show the sender&amp;rsquo;s key id.  To manually import
the key you can use &lt;a href=&#34;http://www.gnupg.org/&#34; title=&#34;GNU Privacy Guard&#34;&gt;&lt;code&gt;gpg&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gpg --recv &amp;lt;the-key-id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This seemed a little labourious, so some automation was in order.
&lt;code&gt;mu4e&lt;/code&gt; allows you to define actions that can be run on messages (or
attachments), so I just wrote an action to do this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;lisp&#34;&gt;(defun mu4e-view-snarf-pgp-key (&amp;amp;optional msg)
  &amp;quot;Snarf the pgp key for the specified message.&amp;quot;
  (interactive)
  (let* ((msg (or msg (mu4e-message-at-point)))
          (path (mu4e-message-field msg :path))
          (cmd (format &amp;quot;%s verify --verbose %s&amp;quot;
                 mu4e-mu-binary
                 (shell-quote-argument path)))
          (output (shell-command-to-string cmd)))
    (let ((case-fold-search nil))
      (when (string-match &amp;quot;key:\\([A-F0-9]+\\)&amp;quot; output)
        (let* ((cmd (format &amp;quot;%s --recv %s&amp;quot;
                            epg-gpg-program (match-string 1 output)))
               (output (shell-command-to-string cmd)))
          (message output))))))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works by parsing the output of the &lt;code&gt;mu&lt;/code&gt; program itself, as
displayed in the &lt;code&gt;Details&lt;/code&gt; window, to obtain the PGP key id.  It then
executes the &lt;code&gt;gpg --recv&lt;/code&gt; command, parsing in the parsed key id.&lt;/p&gt;

&lt;p&gt;To install the action, we simply add it to &lt;code&gt;mu4e-view-actions&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;lisp&#34;&gt;(add-to-list &#39;mu4e-view-actions
             &#39;(&amp;quot;Snarf PGP keys&amp;quot; . mu4e-view-snarf-pgp-key) t)
&lt;/code&gt;&lt;/pre&gt;
</content></entry>

<entry xml:base="http://hugoduncan.github.com/post/clojurescript-libs-with-js-dependencies"><title>How to Build Clojurescript Libs with JavaScript Dependencies</title><link href="http://hugoduncan.github.com/post/clojurescript-libs-with-js-dependencies"/><id>http://hugoduncan.github.com/post/clojurescript-libs-with-js-dependencies</id><published>2013-08-16T00:00:00Z</published><updated>2013-08-16T00:00:00Z</updated><summary type="html"> </summary><content type="html">&lt;p&gt;Using JavaScript dependencies in a Clojurescript library seems to be hard.  It
took me many hours to understand how it should work.  A big thanks to
&lt;a href=&#34;http://cemerick.com&#34; title=&#34;Chas Emerick&#34;&gt;Chas Emerick&lt;/a&gt; for setting me straight on most of this.&lt;/p&gt;

&lt;p&gt;Luke Vanderhart &lt;a href=&#34;http://lukevanderhart.com/2011/09/30/using-javascript-and-clojurescript.html&#34; title=&#34;Luke Vanderhart&#39;s post on JavaScript libs&#34;&gt;posted&lt;/a&gt; a general introduction to using Javascript
libraries in Clojurescript.  Go read it if you haven&amp;rsquo;t already - this post
assumes you have.&lt;/p&gt;

&lt;p&gt;While that post is an excellent description of using JavaScript in
a Clojurescript application, it doesn&amp;rsquo;t really address JavaScript in
Clojurescript libraries, which has the additional problem of how to ensure the
JavaScript dependency is available in the consumer of the library.  A
Clojurescript library should definitely be capable of providing it&amp;rsquo;s
dependencies, but should also allow the consumer to override the version of
these dependencies.&lt;/p&gt;

&lt;h2&gt;Don&amp;rsquo;t package the JavaScript&lt;/h2&gt;

&lt;p&gt;The first approach is to simply not provide the JavaScript at all.  This is the
approach taken by &lt;a href=&#34;https://github.com/ibdknox/jayq&#34; title=&#34;jayq&#34;&gt;jayq&lt;/a&gt; for example.  The consumer of jayq, or any
library that uses jayq, is required to provide jQuery through the JavaScript
runtime.  This can take the form of a &lt;code&gt;&amp;amp;lt;script&amp;amp;gt;&lt;/code&gt; link in the browser page,
or a call to &lt;code&gt;webPage#injectJs&lt;/code&gt; in phantomJS.  The compile &lt;code&gt;:libs&lt;/code&gt; or
&lt;code&gt;:foreign-libs&lt;/code&gt; options can not be used to provide the dependency, as there is
no way for the compiler to know that jayq depends on the namespace provided by
these options.&lt;/p&gt;

&lt;p&gt;For the consumer of the library to use compiler&lt;code&gt;:optimizations&lt;/code&gt; other than
&lt;code&gt;:whitespace&lt;/code&gt;, they will need to provide an &lt;code&gt;:externs&lt;/code&gt; file.&lt;/p&gt;

&lt;h2&gt;Package JavaScript&lt;/h2&gt;

&lt;p&gt;The second approach is to package the JavaScript via a Clojurescript namespace.
This involves adding a &lt;code&gt;require&lt;/code&gt; on a namespace to the code that directly
depends on the JavaScript, and arranging for that Clojurescript namespace to
load the JavaScript, using either of the compiler&lt;code&gt;:libs&lt;/code&gt; or &lt;code&gt;:foreign-libs&lt;/code&gt;
options.&lt;/p&gt;

&lt;p&gt;The Clojurescript library can make the JavaScript library available in its
resources.  The library consumer can then use resource via the &lt;code&gt;:libs&lt;/code&gt; or
&lt;code&gt;:foreign-libs&lt;/code&gt; options, depending on whether or not the JavaScript contains a
&lt;code&gt;goog.provides&lt;/code&gt; call.&lt;/p&gt;

&lt;p&gt;If the library is packaged with a &lt;code&gt;goog.provides&lt;/code&gt; call, then the consumer can
not replace the version using &lt;code&gt;:libs [&amp;quot;&amp;quot;]&lt;/code&gt; - the use of an explicit prefix in
&lt;code&gt;:libs&lt;/code&gt; is needed to prevent more than one JavaScript implementation trying to
provide the clojure namespace, or the use of &lt;code&gt;:foreign-libs&lt;/code&gt; where the namespace
is explicitly mapped.&lt;/p&gt;

&lt;p&gt;For examples, the &lt;a href=&#34;https://github.com/cemerick/pprng&#34; title=&#34;pprng&#34;&gt;pprng&lt;/a&gt; library packages its dependency with a
&lt;code&gt;goog.provides&lt;/code&gt; call, allowing the use of &lt;code&gt;:libs [&amp;quot;&amp;quot;]&lt;/code&gt; to pull in the
dependency.  The &lt;a href=&#34;https://github.com/hugoduncan/papadom&#34; title=&#34;papadom&#34;&gt;papadom&lt;/a&gt; library on the other hand provides vanilla
javascript dependencies, and requires the use of the more verbose
&lt;code&gt;:foreign-libs&lt;/code&gt; option.&lt;/p&gt;

&lt;p&gt;If the JavaScript is to be provided in the runtime, then the consumer will have
to provide an empty namespace definition to satisfy the require in the
Clojurescript library, and the&lt;code&gt;:externs&lt;/code&gt; file as in the first case.&lt;/p&gt;

&lt;h2&gt;Postscript&lt;/h2&gt;

&lt;p&gt;There are several assumptions in much of the documentation that I didn&amp;rsquo;t see
explicitly explained.  I&amp;rsquo;ll record these here for posterity.&lt;/p&gt;

&lt;p&gt;A clojurescript library is always a source code library.  There is no such thing
as the linking of compiled clojurescript artifacts.&lt;/p&gt;

&lt;p&gt;Neither&lt;code&gt;:libs&lt;/code&gt; nor&lt;code&gt;:foreign-libs&lt;/code&gt; actually changes how the JavaScript is
accessed within the clojurescript code.  If you include jQuery via a &lt;code&gt;:libs&lt;/code&gt;,
and a &lt;code&gt;require&lt;/code&gt;, you still access it through &lt;code&gt;js/jQuery&lt;/code&gt;.  The &lt;code&gt;require&lt;/code&gt; of the
namespace specified by &lt;code&gt;goog.provide&lt;/code&gt;, or the namespace specified in the
&lt;code&gt;:foreign-libs&lt;/code&gt;&amp;rsquo; &lt;code&gt;:provides&lt;/code&gt; key, simply ensures the JavaScript is loaded.&lt;/p&gt;

&lt;p&gt;The choice of compiler &lt;code&gt;:optimizations&lt;/code&gt; affects what information you need to
provide, and this differs depending on whether you are providing javascript
libraries through the runtime (e.g. $lt;script&amp;gt; tags in the browser), or
through &lt;code&gt;:libs&lt;/code&gt; or &lt;code&gt;:foreign-libs&lt;/code&gt; compiler options.  The simplest here is to
use the compiler options.  When providing the JavaScript via the runtime, then
everything should also just work if you are using no optimisation, or
just &lt;code&gt;:whitespace&lt;/code&gt;, but as soon as you try anything else, you will need to
provide an :externs definition for the JavaScript libraries.&lt;/p&gt;
</content></entry>

<entry xml:base="http://hugoduncan.github.com/post/webapp_with_core.async"><title>Exploring a todo app with core.async</title><link href="http://hugoduncan.github.com/post/webapp_with_core.async"/><id>http://hugoduncan.github.com/post/webapp_with_core.async</id><published>2013-08-15T00:00:00Z</published><updated>2013-08-15T00:00:00Z</updated><summary type="html"> </summary><content type="html">&lt;p&gt;We&amp;rsquo;re going to build an equivalent of the &lt;a href=&#34;http://angularjs.org/#add-some-control&#34; title=&#34;Angular TODO example&#34;&gt;AngularJS TODO example&lt;/a&gt;
using core.async, and a templating library, &lt;a href=&#34;https://github.com/hugoduncan/papadom&#34; title=&#34;Papadom templating library&#34;&gt;papadom&lt;/a&gt;, that I&amp;rsquo;ve
written to help in this.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/clojure/clojurescript&#34; title=&#34;Clojurescript&#34;&gt;Clojurescript&lt;/a&gt; recently gained a &lt;a href=&#34;http://en.wikipedia.org/wiki/Communicating_sequential_processes&#34; title=&#34;Communicating Sequential Processes&#34;&gt;CSP&lt;/a&gt; implemetation via
&lt;a href=&#34;http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html&#34; title=&#34;Clojure core.async Channels&#34;&gt;core.async&lt;/a&gt;, similar to &lt;a href=&#34;http://golang.org/ref/spec#Channel_types&#34; title=&#34;Go Channels&#34;&gt;Go&amp;rsquo;s channels&lt;/a&gt;, or
&lt;a href=&#34;http://www.cs.cornell.edu/Courses/cs312/2006fa/recitations/rec24.html&#34; title=&#34;CML Channels&#34;&gt;CML&amp;rsquo;s channels&lt;/a&gt; (CML also has a nice select).  Bruce Haumann
started exploring this with &lt;a href=&#34;http://rigsomelight.com/2013/07/18/clojurescript-core-async-todos.html&#34; title=&#34;Bruce Haumann&#39;s &#39;ClojureScript Core.Async Todos&#39;&#34;&gt;ClojureScript Core.Async Todos&lt;/a&gt;, and
David Nolen has been looking at how to use core.async for
&lt;a href=&#34;http://swannodette.github.io/2013/07/31/extracting-processes/&#34; title=&#34;David Nolan&#39;s &#39;CSP is Responsive Design&#39;&#34;&gt;responsive design&lt;/a&gt;.  In this post, we&amp;rsquo;ll take the TODO example,
and take it a little further.&lt;/p&gt;

&lt;h2&gt;Basic Display&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ll start with just displaying a list of todo items.  For this we&amp;rsquo;ll need a
template, so we&amp;rsquo;ll just write this in HTML, and add a &lt;code&gt;t-template&lt;/code&gt; attribute,
which enables us to use mustache style templating of values to display.  This
doesn&amp;rsquo;t use mustache sections for looping, in order to preserve valid HTML
markup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;h1&amp;gt;TODOS&amp;lt;/h1&amp;gt;
&amp;lt;ul class=&amp;quot;unstyled&amp;quot;&amp;gt;
  &amp;lt;li t-template=&amp;quot;todos&amp;quot;&amp;gt;{{text}}&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get this to show something we&amp;rsquo;ll need some code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;(ns app
  (:require
   [papadom.template :refer [compile-templates render]]))

(defn start []
  (compile-templates)
  (render {:todos [{:text &amp;quot;learn papadom&amp;quot; :done false}
                   {:text &amp;quot;write a papadom app&amp;quot; :done false}]}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you call &lt;code&gt;app.start()&lt;/code&gt; from the page containing the above template, you&amp;rsquo;ll
see a list of two todo entries.&lt;/p&gt;

&lt;h2&gt;Adding an event&lt;/h2&gt;

&lt;p&gt;Now we have something displayed, lets add a checkbox to mark todo items as done:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;ul class=&amp;quot;unstyled&amp;quot;&amp;gt;
  &amp;lt;li t-template=&amp;quot;todos&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;checkbox&amp;quot; t-prop=&amp;quot;done&amp;quot; t-event=&amp;quot;done&amp;quot;
           t-id=&amp;quot;index&amp;quot; index=&amp;quot;{{@index}}&amp;quot;&amp;gt;
    &amp;lt;span&amp;gt;{{text}}&amp;lt;/span&amp;gt;
  &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;t-prop&lt;/code&gt; attribute tells the template to which data value to display as the
checkbox.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;t-event&lt;/code&gt; attribute specifies that we want an event.  When the checkbox is
clicked, we will get a core.async message with a &lt;code&gt;:done&lt;/code&gt; event type.  We need to
know which todo was clicked, so we use the &lt;code&gt;t-id&lt;/code&gt; attribute to list the
attributes whose values should be sent as the event data &amp;ndash; in this case the
index, which has a value based on handlebars style &lt;code&gt;@index&lt;/code&gt; property.&lt;/p&gt;

&lt;p&gt;Now we need some code to process the events.  To do this we&amp;rsquo;ll define an
&lt;code&gt;app&lt;/code&gt; function that will be passed a state atom containing a map with our todos
state, and a core.async channel from which to read events.  The function will
loop over events, and dispatch them as required.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;(defn app
  [state event-chan]
  (go
   (loop [[event event-data] (&amp;lt;! event-chan)]
     (case event
       :done
       (let [nv (boolean (:checked event-data))]
         (swap! state assoc-in [:todos (:index event-data) :done] nv)))
     (recur (&amp;lt;! event-chan)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the &lt;code&gt;app&lt;/code&gt; function receives a &lt;code&gt;:done&lt;/code&gt; event, it will update the state atom
appropriately.  Now we have our state updating, we&amp;rsquo;ll need to display it, which
we can again do with the &lt;code&gt;render&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;(defn show-state [state]
  (render &amp;quot;state&amp;quot; state))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We still need to get &lt;code&gt;show-state&lt;/code&gt; called, and we&amp;rsquo;ll arrange this in a modified
&lt;code&gt;start&lt;/code&gt; function.  This will create an atom for the state, and add a watch on
the atom that will call &lt;code&gt;show-state&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;(defn start
  []
  (let [event-chan (chan)
        state (atom nil)]
    (compile-templates)
    (template-events event-chan)
    (add-watch state :state (fn [key ref old new] (show-state new)))
    (reset! state {:todos [{:text &amp;quot;Learn papadom&amp;quot; :done false}
                           {:text &amp;quot;Build a papadom app&amp;quot; :done false}]})
    (app state event-chan))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ve also added a core.async channel, &lt;code&gt;event-chan&lt;/code&gt;, which we&amp;rsquo;ve passed to
&lt;code&gt;template-events&lt;/code&gt; to arrange delivery of the events defined in our template.  We
pass this channel to the &lt;code&gt;app&lt;/code&gt; function to start processing the events.&lt;/p&gt;

&lt;p&gt;This shows the basic structure of the application.&lt;/p&gt;

&lt;h2&gt;Adding New Todo Elements&lt;/h2&gt;

&lt;p&gt;To allow you to add new todo items, we&amp;rsquo;ll add a form to our template,
specifying a &lt;code&gt;t-event&lt;/code&gt; attribute, which will cause an event to be sent when the
form is submitted, with the form&amp;rsquo;s input values as the event data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;html&#34;&gt;&amp;lt;form t-event=&amp;quot;add-todo&amp;quot;&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; t-prop=&amp;quot;text&amp;quot; size=&amp;quot;30&amp;quot; placeholder=&amp;quot;add new todo here&amp;quot;&amp;gt;
  &amp;lt;input class=&amp;quot;btn btn-primary&amp;quot; type=&amp;quot;submit&amp;quot; value=&amp;quot;add&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To process this new event, we&amp;rsquo;ll add a case to the &lt;code&gt;app&lt;/code&gt; function loop&amp;rsquo;s &lt;code&gt;case&lt;/code&gt;
form.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;clj&#34;&gt;:add-todo
(swap! state update-in [:todos]
       conj {:text (:text (input-seq-&amp;gt;map event-data))
             :done false})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This uses the &lt;code&gt;input-seq-&amp;gt;map&lt;/code&gt; helper to convert the data from the form into a
map, and we extract the &lt;code&gt;:text&lt;/code&gt; value (defined by &lt;code&gt;t-prop&lt;/code&gt; in the &lt;code&gt;input&lt;/code&gt;
element).&lt;/p&gt;

&lt;p&gt;And we&amp;rsquo;re done.  To see a full working example have a look at the
&lt;a href=&#34;https://github.com/hugoduncan/papadom/blob/master/examples/todo/resources/public/index.html&#34; title=&#34;TODO HTML Template&#34;&gt;template&lt;/a&gt; and &lt;a href=&#34;https://github.com/hugoduncan/papadom/blob/master/examples/todo/src/papadom/example/todo.cljs&#34; title=&#34;TODO Clojurescript Code&#34;&gt;code&lt;/a&gt; in the todo example of papadom.
To run the example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;shell&#34;&gt;git clone https://github.com/hugoduncan/papadom.git
cd papadom/examples/todo
lein ring server
&lt;/code&gt;&lt;/pre&gt;
</content></entry>

<entry xml:base="http://hugoduncan.github.com/post/configuration_in_templates_is_not_configuration_as_code"><title>Configuration in Templates is not Configuration as Code</title><link href="http://hugoduncan.github.com/post/configuration_in_templates_is_not_configuration_as_code"/><id>http://hugoduncan.github.com/post/configuration_in_templates_is_not_configuration_as_code</id><published>2010-10-04T00:00:00Z</published><updated>2010-10-04T00:00:00Z</updated><summary type="html"> </summary><content type="html">&lt;p&gt;If you have configuration that uses template configuration files, you are practising neither configuration as code nor configuration as data.  Having configuration locked away in template files reduces its visibility, and makes it hard for you to query it. It might be easier to write configuration code to use templates, but it will come back to bite you.&lt;/p&gt;

&lt;p&gt;One of the first things I implemented in &lt;a href=&#34;http://github.com/hugoduncan/pallet&#34;&gt;pallet&lt;/a&gt; was a templating mechanism, because configuration management tools use templates, right?  I even built a template selection mechanism, just like &lt;a href=&#34;http://wiki.opscode.com/display/chef/Templates&#34;&gt;Chef&#39;s&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I have come to realise however, that having configuration in template files is not particularly useful. There are three major problems you are likely to encounter.  Firstly template files are not visible, secondly you can not query the data in the template files, and lastly you will need to touch multiple files to add or modify parameters.&lt;/p&gt;

&lt;p&gt;Visibility at the point of usage is important, especially in a team environment.  If you have to find the template file and look at its content when reading your configuration code, then the chances are you assume it hasn&#39;t changed, and skip the contents. Making an analogy to the world of software development, templates are like global variables in one sense. You can change the operation of a program with a global variable modified in some obscure place, and in the same way, you can change your system configuration by changing a template file, tucked away in some folder, and not visible from where you are actually calling your configuration crate/recipe.&lt;/p&gt;

&lt;p&gt;The ability to query configuration settings allows not just finding out, for example,  which directory a log file is in, but also enables you to put tools on top of your configuration data.  Template configuration files suffer on two counts here - they are separate text files that require parsing to be read, and the format of each configuration file is different.&lt;/p&gt;

&lt;p&gt;The last point concerns the flexibility of your configuration. If you have used template files, with hard coded parameter values, and you then want to modify your configuration to dynamically set one of those hard coded values, you have to modify all the specialised versions of the existing templates, and specify the value in code. You have to touch multiple files - lots of room for making typos.&lt;/p&gt;

&lt;p&gt;My goal for pallet then, is to have all configuration supplied as arguments to crates.  For most packages a hash map is sufficient an abstraction for providing the data, but when this gets too cumbersome, we&#39;ll use a DSL that mirrors the original configuration file language.&lt;/p&gt;

&lt;p&gt;Goodbye hidden configuration!&lt;/p&gt;
</content></entry>

<entry xml:base="http://hugoduncan.github.com/post/configure_nagios_using_pallet"><title>Configure Nagios using Pallet</title><link href="http://hugoduncan.github.com/post/configure_nagios_using_pallet"/><id>http://hugoduncan.github.com/post/configure_nagios_using_pallet</id><published>2010-08-18T00:00:00Z</published><updated>2010-08-18T00:00:00Z</updated><summary type="html"> </summary><content type="html">&lt;p&gt;Basic Nagios support was recently added to &lt;a href=&#34;http://github.com/hugoduncan/pallet&#34;&gt;pallet&lt;/a&gt;, and while very simple to use, this blog post should make it even simpler. The overall philosophy is to configure the nagios service monitoring definitions along with the service itself, rather than have monolithic nagios configuration, divorced from the configuration of the various nodes.&lt;/p&gt;

&lt;p&gt;As an example, we can configure a machine to have it&#39;s ssh service, CPU load, number of processes and number of users monitored. Obviously, you would normally be monitoring several different types of nodes, but there is no difference as far as pallet is concerned.&lt;/p&gt;

&lt;p&gt;We start by requiring various pallet components.  These would normally be part of a &lt;code&gt;ns&lt;/code&gt; declaration, but are provided here for ease of use at the REPL.&lt;/p&gt;

&lt;pre class=&#34;clojure&#34;&gt;
(require
  &#39;[pallet.crate.automated-admin-user
    :as admin-user]
  &#39;[pallet.crate.iptables :as &#39;iptables]
  &#39;[pallet.crate.ssh :as ssh]
  &#39;[pallet.crate.nagios-config
     :as nagios-config]
  &#39;[pallet.crate.nagios :as nagios]
  &#39;[pallet.crate.postfix :as postfix]
  &#39;[pallet.resource.service :as service])
&lt;/pre&gt;

&lt;h2&gt;Node to be Monitored by Nagios&lt;/h2&gt;

&lt;p&gt;Now we define the node to be monitored. We set up a machine that has &lt;abbr&gt;SSH&lt;/abbr&gt; running, and configure &lt;code&gt;iptables&lt;/code&gt; to allow access to &lt;abbr&gt;SSH&lt;/abbr&gt;, with a throttled connection rate (six connections/minute by default).&lt;/p&gt;

&lt;pre class=&#34;clojure&#34;&gt;
(pallet.core/defnode monitored
  []
  :bootstrap [(admin-user/automated-admin-user)]
  :configure [;; set iptables for restricted access
              (iptables/iptables-accept-icmp)
              (iptables/iptables-accept-established)
              ;; allow connections to ssh
              ;; but throttle connection requests
              (ssh/iptables-throttle)
              (ssh/iptables-accept)])
&lt;/pre&gt;

&lt;p&gt;Monitoring of the &lt;abbr&gt;SSH&lt;/abbr&gt; service is configured by simply adding
&lt;code&gt;(ssh/nagios-monitor)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Remote monitoring is implemented using nagios&#39; &lt;code&gt;nrpe&lt;/code&gt; plugin, which we add with &lt;code&gt;(nagios-config/nrpe-client)&lt;/code&gt;.  To make nrpe accessible to the nagios server, we open the that the nrpe agent runs on using &lt;code&gt;(nagios-config/nrpe-client-port)&lt;/code&gt;, which restricts access to the nagios server node. We also add a phase, :restart-nagios, that can be used to restart the nrpe agent.&lt;/p&gt;

&lt;p&gt;Pallet comes with some configured nrpe checks, and we add &lt;code&gt;nrpe-check-load&lt;/code&gt;, &lt;code&gt;nrpe-check-total-proces&lt;/code&gt; and &lt;code&gt;nrpe-check-users&lt;/code&gt;. The final configuration looks like this:&lt;/p&gt;

&lt;pre class=&#34;clojure&#34;&gt;
(pallet.core/defnode monitored
  []
  :bootstrap [(admin-user/automated-admin-user)]
  :configure [;; set iptables for restricted access
              (iptables/iptables-accept-icmp)
              (iptables/iptables-accept-established)
              ;; allow connections to ssh
              ;; but throttle connection requests
              (ssh/iptables-throttle)
              (ssh/iptables-accept)
              ;; monitor ssh
              (ssh/nagios-monitor)
              ;; add nrpe agent, and only allow
              ;; connections from nagios server
              (nagios-config/nrpe-client)
              (nagios-config/nrpe-client-port)
              ;; add some remote checks
              (nagios-config/nrpe-check-load)
              (nagios-config/nrpe-check-total-procs)
              (nagios-config/nrpe-check-users)]
  :restart-nagios [(service/service
                    &#34;nagios-nrpe-server&#34;
                    :action :restart)])
&lt;/pre&gt;

&lt;p&gt;&lt;h2&gt;Nagios Server&lt;/h2&gt;
&lt;p&gt;We now configure the nagios server node. The nagios server is installed with &lt;code&gt;(nagios/nagios &amp;ldquo;nagiospwd&amp;rdquo;)&lt;/code&gt;, specifying the password for the nagios web interface, and add a phase, :restart-nagios, that can be used to restart nagios.&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;Nagios also requires a &lt;abbr&gt;MTA&lt;/abbr&gt; for notifications, and here we install postfix.  We add a contact, which we make a member of the &#34;admins&#34; contact group, which is notified as part of the default host and service templates.&lt;/p&gt;

&lt;pre class=&#34;clojure&#34;&gt;
(pallet.core/defnode nagios
  []
  :bootstrap [(admin-user/automated-admin-user)]
  :configure [;; restrict access
              (iptables/iptables-accept-icmp)
              (iptables/iptables-accept-established)
              (ssh/iptables-throttle)
              (ssh/iptables-accept)
              ;; configure MTA
              (postfix/postfix
               &#34;pallet.org&#34; :internet-site)
              ;; install nagios
              (nagios/nagios &#34;nagiospwd&#34;)
              ;; allow access to nagios web site
              (iptables/iptables-accept-port 80)
              ;; configure notifications
              (nagios/contact
              {:contact_name &#34;hugo&#34;
               :service_notification_period &#34;24x7&#34;
               :host_notification_period &#34;24x7&#34;
               :service_notification_options
                  &#34;w,u,c,r&#34;
               :host_notification_options
                  &#34;d,r&#34;
               :service_notification_commands
                 &#34;notify-service-by-email&#34;
               :host_notification_commands
                  &#34;notify-host-by-email&#34;
               :email &#34;my.email@my.domain&#34;
               :contactgroups [:admins]})]
  :restart-nagios [(service/service &#34;nagios3&#34;
                     :action :restart)])
&lt;/pre&gt;

&lt;p&gt;&lt;h2&gt;Trying it out&lt;/h2&gt;
&lt;p&gt;That&amp;rsquo;s it. To fire up both machines, we use pallet&amp;rsquo;s &lt;code&gt;converge&lt;/code&gt; command.&lt;/p&gt;&lt;/p&gt;

&lt;pre class=&#34;clojure&#34;&gt;
(pallet.core/converge
  {monitored 1 nagios 1} service
  :configure :restart-nagios)
&lt;/pre&gt;

&lt;p&gt;The nagios web interface is then accessible on the &lt;code&gt;nagios&lt;/code&gt; node with the &lt;code&gt;nagiosadmin&lt;/code&gt; user and specified password.  Real world usage would probably have several different monitored configurations, and restricted access to the &lt;code&gt;nagios&lt;/code&gt; node.&lt;/p&gt;

&lt;p&gt;&lt;h2&gt;Still to do&amp;hellip;&lt;/h2&gt;
&lt;p&gt;Support for nagios is not complete (e.g. remote command configuration still needs to be added, and it has only been tested on Ubuntu), but I would appreciate any feedback on the general approach.&lt;/p&gt;&lt;/p&gt;
</content></entry>

<entry xml:base="http://hugoduncan.github.com/post/mocking_clojure_functions_with_atticus"><title>Mocking Clojure Functions with Atticus</title><link href="http://hugoduncan.github.com/post/mocking_clojure_functions_with_atticus"/><id>http://hugoduncan.github.com/post/mocking_clojure_functions_with_atticus</id><published>2010-05-18T00:00:00Z</published><updated>2010-05-18T00:00:00Z</updated><summary type="html"> </summary><content type="html">&lt;p&gt;&lt;p&gt;I dislike most mocking, and try and avoid it as much as possible. Sometimes
it is however the only realistic way of testing.  I did a quick survey of
mocking tools in clojure, and found them very much reflecting the Java mocking
libraries. Clojure has a few more dynamic capabilities than Java, so I thought a
little about how these could be used to make a simple mocking facility, and &lt;a href=&#34;http://github.com/hugoduncan/atticus&#34;&gt;atticus&lt;/a&gt; is what I came up
with.&lt;/p&gt;
&lt;p&gt;There is a consensus that mocking should be implemented by binding a
function&amp;rsquo;s var to a new function for the duration of a test, and atticus does
this too. Atticus&amp;rsquo; premise is that we can do simple mocking by declaring the
mock function as a local function definition, and have the local function do the
argument checking, return value setting, etc.  The simplest case would be
something like below, which checks the value of its argument and specifies a
return value:&lt;/p&gt;
&lt;pre class=&#34;clojure&#34;&gt;
;; pull in namespaces
(use &amp;lsquo;clojure.test)
(require &amp;lsquo;atticus.mock)&lt;/p&gt;

&lt;p&gt;;; define test which mocks f
(deftest mock-test
  (atticus.mock/expects
    [(f &lt;a href=&#34;is (= arg 1&#34;&gt;arg&lt;/a&gt; &amp;ldquo;Check argument&amp;rdquo;)
       arg)] ; set the return value
    ;; in a real test case this would be called
    ;; indirectly by some other function
    (is (= 1 (f 1)) &amp;ldquo;Call mocked function&amp;rdquo;))
&lt;/pre&gt;
&lt;p&gt;At the moment, I have added two macros to this.  &lt;code&gt;once&lt;/code&gt;, which
checks a function is called once, and &lt;code&gt;times&lt;/code&gt;, which checks that a
function is called a specific number of times. The macros are used to wrap the
body of the mock function, which keeps the function&amp;rsquo;s expected behaviour in one
place.&lt;/p&gt;
&lt;pre class=&#34;clojure&#34;&gt;
;; define test, that should be called just once
(deftest mock-test
  (atticus.mock/expects
    &lt;a href=&#34;is (= 1 (f 1&#34;&gt;(f &lt;a href=&#34;atticus.mock/once
         (is (= arg 1&#34;&gt;arg&lt;/a&gt; &amp;ldquo;Check argument&amp;rdquo;)
         arg))&lt;/a&gt;) &amp;ldquo;Call mocked function&amp;rdquo;))
&lt;/pre&gt;
&lt;pre class=&#34;clojure&#34;&gt;
;; define test, that should be called exactly twice
(deftest mock-test
  (atticus.mock/expects
    &lt;a href=&#34;is (= 1 (f 1&#34;&gt;(f &lt;a href=&#34;atticus.mock/times 2
         (is (= arg 1&#34;&gt;arg&lt;/a&gt; &amp;ldquo;Check argument&amp;rdquo;)
         arg))&lt;/a&gt;) &amp;ldquo;Call mocked function&amp;rdquo;)
    (is (= 1 (f 1)) &amp;ldquo;Call mocked function&amp;rdquo;))
&lt;/pre&gt;
&lt;p&gt;So what do you think, is this a reasonable approach? Not having the explicit
calls to &lt;code&gt;returns&lt;/code&gt;, etc, might be seen as a loss of declarative
clarity, but I for one prefer this, as it gives you the full power of the
language to test the arguments and set the return value.&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://s-expressions.com/2010/01/24/conjure-simple-mocking-and-stubbing-for-clojure-unit-tests/&#34;&gt;conjure – simple mocking and stubbing for Clojure unit-tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://richhickey.github.com/clojure-contrib/mock-api.html&#34;&gt;clojure.contrib.mock&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://code.google.com/p/test-expect/&#34;&gt;test-expect&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.n01se.net/?p=134&#34;&gt;Using binding to mock out even “direct linked” functions in Clojure&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
</content></entry>

</feed>
