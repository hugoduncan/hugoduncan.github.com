<!DOCTYPE html>
<html lang="en">
  <head>
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta charset="utf-8"/>
    <meta name="description"
          content="Pelure - ephemeral writing surface?"/>
    <meta name="author" content="Hugo Duncan"/>
    <link type="application/atom+xml" rel="alternate" href="index.xml" title="Pelure">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>

    <div class="site-header">
      <div class="wrapper">
        <div class="site-nav">
          <a class="page-link" href="archive.html">All Posts</a>
          <a class="page-link" href="https://github.com/hugoduncan/hugoduncan.github.com/discussions/categories/posts">Discuss</a>
          <a class="page-link" href="meta/pelure.html">About</a>
          <a class="page-link" href="meta/contact.html">Contact</a>
          <a class="page-link" href="index.xml">
            <img class="page-icon"
                 src="https://www.svgrepo.com/show/362316/feed.svg"
                 width="30px"/>
          </a>
          <a class="page-link" href="https://twitter.com/hugoduncan">
            <img class="page-icon"
                 src="https://www.svgrepo.com/show/11841/twitter.svg"
                 width="30px"/>
          </a>
        </div>
        <div>
          <h1 class="site-title">
            <a class="page-link" href="index.html">Pelure</a>
          </h1>
          <p>Ephemeral musings, often about Clojure</p>
        </div>
      </div>
    </div>

    <div class="wrapper">

      <div><h1><a href="post/versions_in_the_time_of_git_dependencies.html">Versions in the Time of Git Dependencies</a></h1><blockquote><p> He allowed himself to be swayed by his conviction that human beings  are not born once and for all on the day their mothers give birth to  them, but that life obliges them over and over again to give birth to  themselves.”  ― Gabriel García Márquez, Love in the Time of Cholera </p></blockquote><p>When you want to consume a library using git dependencies, you go to the project's GitHub page, lookup the SHA from the <code>README</code>, put it in your <code>deps.edn</code>, and your done, right? &ndash; But what happens when you want to upgrade? rinse and repeat?  How do you even know that a new release is available?</p><h2>On Git</h2><p>A git repository is an append only log of changes to a project, and Together with the repository url, the SHA forms a content based addressing scheme to a particular state of the project.  This is a natural identifier for that particular project state.</p><p>As consumers of a library, we aren't concerned with every single commit made to the repository - we want to know the SHA that the project's maintainers consider to be a release.  We might not want the main branch HEAD commit, depending on the branching model used by the project developers.</p><h2>A CI Pipeline</h2><p>A good CI pipeline takes an immutable project artifact, and put's it through increasingly vigorous testing.  It might start of as an alpha, or a release candidate, and as confidence is increased through testing, it can be promoted to a full release.</p><p>An artifact built from the contents of a single git SHA fits this model nicely.  In an open source world, we can think of a SHA as an alpha release, that gets tested by a small number of people, and then gets published as a release - tools.build seems to follow this model for example, with announcement of alphas on #tools.build, followed by release announcements, for the same SHA, on #announce after a few people have tried it.</p><h2>A new SHA, a new Version?</h2><p>So which SHA do we want to put in our <code>deps.edn</code>?</p><p>In the maven world, versions are ordered, so when a new version is published, it is a signal that can be used by tooling to determine if an update is available.</p><p>In the git world, a SHA is not ordered, so how do we know when a new version is available?  Should we check slack, or a blog, or the project's home page? or could we as project authors provide data to allow automation of this process?</p><h2>release.edn</h2><p>To provide release information, we could put the version information into the repository itself.</p><p>There are many release schemes, but we can model a project's releases as falling into release streams.  Examples of this are "stable" or "alpha" or "v4.x".  A release for each stream is then just a SHA associated with the stream.</p><p>A natural way to present this would be as a map in an EDN file (or JSON, or YAML, this doesn't need to be clojure specific).</p><p><pre><code class="clojure hljs"><span class="forms"><span class="map">{<span class="keyword">:stable</span> <span class="map">{<span class="keyword">:git/tag</span> <span class="string">&quot;v1.0.0&quot;</span> <span class="keyword">:git/sha</span> <span class="string">&quot;abcdef&quot;</span>}</span><br> <span class="keyword">:alpha</span> <span class="map">{<span class="keyword">:git/tag</span> <span class="string">&quot;v1.1.0&quot;</span> <span class="keyword">:git/sha</span> <span class="string">&quot;abcdef&quot;</span>}</span><br> <span class="keyword">:head</span> <span class="map">{<span class="keyword">:git/tag</span> <span class="string">&quot;master&quot;</span> <span class="keyword">:git/sha</span> <span class="keyword">:latest</span>}</span>}</span></span></code></pre></p><p>A polylith or other monolith repository could have different streams for the various artifacts it published.</p><p>If we decide on this format, we then need to make the file discoverable. One way one be to take it from a git repository's default branch, which seems like a good default.</p><p>The final piece of the puzzle would be for tooling like <a href='https://github.com/liquidz/antq'>antq</a> and <a href='https://github.com/nnichols/clojure-dependency-update-action'>clojure-dependency-update-action</a> to use this information.</p><h2>Good idea?</h2><p>I'm sure I can't be the first to have thought of this.</p><p>What do you think - is this useful? How could the idea be improved?</p><p>Discuss this post <a href="https://github.com/hugoduncan/hugoduncan.github.com/discussions/5">here</a>.</p><p><i>Published: 2021-11-21</i></p></div><div><h1><a href="post/back_to_blogging.html">Back to blogging</a></h1><blockquote><p> “My mind turned by anxiety, or other cause, from its scrutiny of blank  paper, is like a lost child–wandering the house, sitting on the bottom  step to cry.”  — Virginia Woolf </p></blockquote><p>I was inspired to write some blog posts, which led me to realise my current blog and blogging setup were completely broken.</p><p>Michiel Borkent (<a href='https://twitter.com/borkdude'>@borkdude</a>) recently wrote about his <a href='https://blog.michielborkent.nl/migrating-octopress-to-babashka.html'>migration from Octopress</a>. His requirements were very similar to mine, so I copied and modified. Thank you Michiel!</p><p>His blog, <a href='https://blog.michielborkent.nl/'>REPL adventures</a>, is well worth the read.</p><h2>Blog Post Discussions</h2><p>With a static web site, the perennial problem is how to enable discussions.  Some people just punt pn this, and point to reddit, but Michiel's solution is to use github discussions.  As a way of owning the discussion, this has a lot of appeal.</p><p>I think it could be taken further.  It would be great if we could automate the creation of a blog post topic when creating a blog post. Unfortunately the <a href='https://cli.github.com/'><code>gh</code></a> command line client doesn't support discussions yet, so that would require using Github's GraphQL API - more work than I wanted to do for now.</p><p>One downside though, is that the discussions are not visible on the blog pages, where discussion could easily engender more discussion. I wonder if a Github Action could be triggered by conversation activity, and automatically republish the post with the discussion to date at the end of the post.</p><h2>Blogging Frameworks vs Tasks</h2><p>There are many blog site generators (I used <a href='https://gohugo.io/'>Hugo</a>, of course), even if we limit ourselves to clojure:- <a href='https://github.com/retrogradeorbit/bootleg'>bootleg</a>, <a href='https://github.com/rafaeldelboni/nota'>nota</a>, <a href='https://github.com/cryogen-project/cryogen'>cryogen</a>, and <a href='https://github.com/nakkaya/static'>static</a> to name a few.</p><p>These are usually feature rich.  The price for those features though, is extra complexity.</p><p>Michiel's blog uses <a href='https://book.babashka.org/'>babashka</a> tasks to add a post, render posts, etc. These are extremely quick to run and make maintaining the blog simple.  it does just what he needs, and no more.</p><p>This reminds me of project automation, and the <a href='https://clojure.org/guides/tools_build'><code>tools.build</code></a> approach of using composable code tasks to build just what is needed.</p><p>Maybe there is an opportunity to take the same approach for building a blog or static site. If we could pick from a selection of configurable tasks, maybe we wouldn't need to write our own.</p><p>Speaking of which, I have tried writing my own before, in common-lisp: <a href='http://github.com/hugoduncan/cl-blog-generator'>cl-blog-generator</a>.</p><h2>And…</h2><p>So I have a blogging setup.  Now I just need to write something.</p><p><!&mdash; [borkdude-octopress][https://blog.michielborkent.nl/migrating-octopress-to-babashka.html] [borkdude-blog][https://blog.michielborkent.nl/] [cryogen][https://github.com/cryogen-project/cryogen] [static][https://github.com/nakkaya/static] [nota][https://github.com/rafaeldelboni/nota] [hugo][https://gohugo.io/] [babashka][https://book.babashka.org/] [tools.build][https://clojure.org/guides/tools_build] [gh][https://cli.github.com/] [bootleg][https://github.com/retrogradeorbit/bootleg] &mdash;></p><p>Discuss this post <a href="https://github.com/hugoduncan/hugoduncan.github.com/discussions/4">here</a>.</p><p><i>Published: 2021-11-14</i></p></div><div><h1><a href="post/generating_source_with_leiningen.html">Generating Source Files with Leiningen</a></h1><p>Recently, we needed to include some generated source files in a project.  The source code generation was project specific, so we didn't want to have to create a leiningen plugin specifically for it. To get this to work required using quite a few of <a href='https://github.com/technomancy/leiningen#leiningen'>leiningen's</a> features.</p><p>This post will explain how to use lein to customise you build to generates a source file, but many of the steps are useful to implement any form of lein build customisation.</p><h3>The Generator</h3><p>The source code generator is going to live in the <code>my.src-generator</code> namespace.  Here's an example, that just generates a namespace declaration for the <code>my.gen</code> namespace under <code>target/generated/my/gen.clj</code>.</p><p><pre><code class="clojure hljs"><span class="forms"><span class="list">(<span class="symbol">ns</span> <span class="symbol">my.src-generator</span><br>  <span class="list">(<span class="keyword">:require</span> <span class="vector">&#91;<span class="symbol">clojure.java.io</span> <span class="keyword">:refer</span> <span class="vector">&#91;<span class="symbol">file</span>&#93;</span>&#93;</span>)</span>)</span><br><br><span class="list">(<span class="symbol">defn</span> <span class="def">generate</span> <span class="vector">&#91;&#93;</span><br>  <span class="list">(<span class="symbol">doto</span> <span class="list">(<span class="symbol">file</span> <span class="string">&quot;target&quot;</span> <span class="string">&quot;generated&quot;</span> <span class="string">&quot;my&quot;</span> <span class="string">&quot;gen.clj&quot;</span>)</span><br>    <span class="list">(<span class="symbol">-&gt;</span> <span class="fn">#(<span class="symbol">.getParentFile</span>)</span> <span class="fn">#(<span class="symbol">.mkdirs</span>)</span>)</span><br>    <span class="list">(<span class="symbol">spit</span> <span class="string">&quot;(ns my.gen)&quot;</span>)</span>)</span>)</span></span></code></pre></p><h3>Development only code</h3><p>The source generation code should not be packaged in the jar, so we place it in <code>dev-src/my/src&#95;generator.clj</code>, and add <code>dev-src</code> and the generated source directories to the <code>:dev</code> profile's <code>:source-paths</code>. The <code>:dev</code> profile is automatically used by leiningen unless it is producing a jar file.  When producing the jar, the <code>dev</code> profile will not be used, so <code>dev-src</code> will not be on the <code>:source-path</code> (we add the generated directory to the base <code>:source-path</code> below).</p><p><pre><code class="clojure hljs"><span class="forms"><span class="keyword">:profiles</span> <span class="map">{<span class="keyword">:dev</span> <span class="map">{<span class="keyword">:source-paths</span> <span class="vector">&#91;<span class="string">&quot;src&quot;</span> <span class="string">&quot;dev-src&quot;</span> <span class="string">&quot;target/generated&quot;</span>&#93;</span>}</span>}</span></span></code></pre></p><h3>Running project specific code with leininingen</h3><p>The <code>run</code> task can be used to invoke code in your project.  To use lein's <code>run</code> task we need to add a <code>-main</code> function to the <code>my.src-generator</code> namespace.</p><p><pre><code class="clojure hljs"><span class="forms"><span class="list">(<span class="symbol">defn</span> <span class="def">-main</span> <span class="vector">&#91;<span class="symbol">&amp;</span> <span class="local">args</span>&#93;</span><br>  <span class="list">(<span class="symbol">generate</span>)</span>)</span></span></code></pre></p><p>In the <code>project.clj</code> file we also tell lein about the main namespace. In order to avoid AOT compilation of the main namespace, we mark it with <code>:skip-aot</code> metadata.</p><p><pre><code class="clojure hljs"><span class="forms"><span class="keyword">:main</span> <span class="meta">&#94;<span class="keyword">:skip-aot</span> <span class="symbol">my.src-generator</span></span></span></code></pre></p><h3>Customising the jar contents</h3><p>The generated files need to end up in the jar (and possibly be compiled), so we put them on the <code>:source-paths</code> in the project.  If we had wanted to include the sources without further processing, we could have added the generated directory to <code>:resource-paths</code> instead.</p><p><pre><code class="clojure hljs"><span class="forms"><span class="keyword">:source-paths</span> <span class="vector">&#91;<span class="string">&quot;src&quot;</span> <span class="string">&quot;target/generated&quot;</span>&#93;</span></span></code></pre></p><h3>Extending the build process</h3><p>Now we can tell lein to generate the source files whenever we use the project.  We do this by adding the <code>run</code> task to the <code>:prep-tasks</code> key.  Leiningen runs all the tasks in <code>:prep-tasks</code> before any task invoked by the lein command line.</p><p>The tricky bit here is that the <code>run</code> task will itself invoke the <code>:prep-tasks</code>, so we want to make sure we don't end up calling the task recursively and generating a stack overflow.  To solve this, add a <code>gen</code> profile, and disable the prep tasks in it.  We use the <code>:replace</code> metadata to ensure this definition takes precedence.  See the <a href='https://github.com/technomancy/leiningen/blob/master/doc/PROFILES.md#merging'>leiningen profile documentation</a> for more information on <code>:replace</code> and it's sibling <code>:displace</code>.</p><p><pre><code class="clojure hljs"><span class="forms"><span class="keyword">:gen</span> <span class="map">{<span class="keyword">:prep-tasks</span> <span class="meta">&#94;<span class="keyword">:replace</span> <span class="vector">&#91;&#93;</span></span>}</span></span></code></pre></p><p>Then use this profile when setting the <code>:prep-tasks</code> key in the project.</p><p><pre><code class="clojure hljs"><span class="forms"><span class="keyword">:prep-tasks</span> <span class="vector">&#91;<span class="vector">&#91;<span class="string">&quot;with-profile&quot;</span> <span class="string">&quot;+gen,+dev&quot;</span> <span class="string">&quot;run&quot;</span>&#93;</span>  <span class="string">&quot;compile&quot;</span>&#93;</span></span></code></pre></p><p>Now when we run any command, the sources are generated.</p><h3>Adding an alias</h3><p>Finally we may want to just invoke the source generation, so let's create an alias to make <code>lein gen</code> run the generator.  We need the <code>gen</code> profile for this, or otherwise the generator will run twice.</p><p><pre><code class="clojure hljs"><span class="forms"><span class="keyword">:aliases</span> <span class="map">{<span class="string">&quot;gen&quot;</span> <span class="vector">&#91;<span class="string">&quot;with-profile&quot;</span> <span class="string">&quot;+gen,+dev&quot;</span> <span class="string">&quot;run&quot;</span>&#93;</span>}</span></span></code></pre></p><h3>The final project.clj</h3><p>For reference, the final project.clj looks like this:</p><p><pre><code class="clojure hljs"><span class="forms"><span class="list">(<span class="symbol">defproject</span> <span class="symbol">my-proj</span> <span class="string">&quot;0.1.0-SNAPSHOT&quot;</span><br>  <span class="keyword">:dependencies</span> <span class="vector">&#91;<span class="vector">&#91;<span class="symbol">org.clojure/clojure</span> <span class="string">&quot;1.4.0&quot;</span>&#93;</span>&#93;</span><br>  <span class="keyword">:source-paths</span> <span class="vector">&#91;<span class="string">&quot;src&quot;</span> <span class="string">&quot;target/generated&quot;</span>&#93;</span><br>  <span class="keyword">:main</span> <span class="meta">&#94;<span class="keyword">:skip-aot</span> <span class="symbol">my.src-generator</span></span><br>  <span class="keyword">:prep-tasks</span> <span class="vector">&#91;<span class="vector">&#91;<span class="string">&quot;with-profile&quot;</span> <span class="string">&quot;+gen,+dev&quot;</span> <span class="string">&quot;run&quot;</span>&#93;</span>  <span class="string">&quot;compile&quot;</span>&#93;</span><br>  <span class="keyword">:profiles</span> <span class="map">{<span class="keyword">:dev</span> <span class="map">{<span class="keyword">:source-paths</span> <span class="vector">&#91;<span class="string">&quot;src&quot;</span> <span class="string">&quot;dev-src&quot;</span> <span class="string">&quot;target/generated&quot;</span>&#93;</span>}</span><br>             <span class="keyword">:gen</span> <span class="map">{<span class="keyword">:prep-tasks</span> <span class="meta">&#94;<span class="keyword">:replace</span> <span class="vector">&#91;&#93;</span></span>}</span>}</span><br>  <span class="keyword">:aliases</span> <span class="map">{<span class="string">&quot;gen&quot;</span> <span class="vector">&#91;<span class="string">&quot;with-profile&quot;</span> <span class="string">&quot;+gen,+dev&quot;</span> <span class="string">&quot;run&quot;</span>&#93;</span>}</span>)</span></span></code></pre></p><h3>Conclusion</h3><p>This required using many of lein's features to get working - hopefully you'll find a use for some of them.</p><p>Discuss this post <a href="https://github.com/hugoduncan/hugoduncan.github.com/discussions/categories/posts">here</a>.</p><p><i>Published: 2013-10-28</i></p></div>

      
      <div style="margin-bottom: 20px; float: right;">
        <a class="page-link" href="archive.html">Archive</a>
      </div>
      
    </div>
    <script>
      document.addEventListener('DOMContentLoaded', (event) => {
        document.querySelectorAll('pre code').forEach((el) => {
          if (!el.classList.contains('clojure')) {
            hljs.highlightElement(el);
          }
        });
      });
    </script>
  </body>
</html>
